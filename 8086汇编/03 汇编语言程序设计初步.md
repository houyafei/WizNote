# 一 汇编语言的语句

1 语句的种类和格式

汇编语言有两种类型的语句，一种是**指令语句**，另一种是**伪指令语句**。

**区别：**

  指令语句有对应的机器指令，而伪指令语句没有

  伪指令只是指示汇编程序如何汇编源程序,包括符号的定义、变量的定义、段的定义等。（更简单的说法，非指令语句的就是伪指令语句）

| 指令语句格式：[标号:] 指令助记符 [操作数[,操作数]] ;注释 |
| -------------------------------------------------------- |
| 伪指令语句格式：[名字] 伪指令助记符 [参数[,参数]] ;注释  |

标号和名字一般最多由**31**个字母、数字及**4**个规定的特殊字符( **? @ _ $** )等组成，并且不能使用数字开头，默认不区分标号和名字的大小写，除非要求汇编程序进行区分。例外，汇编语言不区保留字中的字母分大小写。

# **二 数值表达式（伪指令）**

  在汇编语言中，不仅有各种类型的运算符，还有许多操作符。通过运算符、操作符和括号把常熟和符号连起来，就得到表达式。

表达式又分为**数值表达式**和**地址表达式**。上述指令语句中的操作数和伪指令语句中的参数在许多场合下只是数值表达式。

  所谓**数值表达式**，是指在汇编过程中能够由汇编程序计算出数值的表达式。（执行之前已经能够计算出数值的表达式）

## 1 常数

  十进制数（D）、十六进制数（H）、二进制数（B）、八进制数（O）、字符串常数(单引号,双引号皆可,只要配对)

## 2 算术运算符

  正(+) 负(-) 加(+) 减(-) 乘(*) 除(/) 模(MOD)。例如：

 

```
mov ax,100*4+2; 
sub cx,100h/2; 
mov al,-3
```

## 3 关系运算符

  相等(EQ)、不等(NE)、大于(GT)、小于(LT)、小于等于(LE)、大于等于(GE)。

  运算结果是一个数字值，如果关系不成立，结果为0，否则额若关系成立，结果为0FFFFh。例如：

 

```
mov ax,1234h GT 1024H ;汇编后--> mov ax,0FFFFh
```

## 4 逻辑运算符

  与(AND)、或(OR)、异或(XOR)、非(NOT)、左移(SHL)、右移(SHR),逻辑运算的结果也是数值。例如：

 

```
    mov ax,1 SHL 3;        --> mov ax,8
    or  al,3 AND 47H       --> or  al,40H
    and bl,NOT(7 OR 54H)   --> and bl,0A8H
```

## 5 操作符

  HIGH（取表达式高8位）/LOW（取表达式低8位）

  LENGTH/SIZE

  OFFSET/SEG/

  TYPE/ 

（WIDTH/MASK）-- **记录专用操作符（第7章）**

## 6 运算符和操作符的优先级

（1）圆括号、尖括号、方括号、圆点符、LENGTH、SIZE、WIDTH、MASK、其中，尖括号用于记录中，圆点符用于结果中

（2）PTR、OFFSET、SEG、TYPE、THIS、冒号。其中，冒号用于表示段超越前缀。

（3）*、/、MOD、SHL、SHR、

（4）HIGH、LOW

（5）+、-

（6）EQ、NE、LT、LE、GT、GE

（7）NOT

（8）AND

（9）OR、XOR

（10）SHORT

## 三 地址表达式（伪指令）

  **地址表达式**所表示的是存储器操作数的地址。单个的标号(对应直接寻址方式)和有方括号的基址或变址寄存器(对应寄存器间接寻址)的地址表达式的特例。

在一个存储器地址（如变量或标号）上加减一个数字量，结果仍为存储器地址。例如：

 

```
mov ax, VARW + 4 
;VARW是标号，则ax得到VARW所在地址偏移4字节的地址            
;VARW是变量，则ax得到VARW的值+4.
mov CARW + 4, ax   
;VARW是变量，ax的值保存到CRAW地址偏移4字节的位置
;VARW是标号编译错误。
mov ax,[VARW2+1] ;如果VARW2是变量，则ax被赋给VARW2地址偏移1个字节指向的数据
mov ax,[ADDR1+1] ;如果ADDR1是标号，则ax被赋给ADDR1地址+1(注意:这种情况源操作数和目的操作数不能交换
```

# 三 变量和标号（伪指令）

变量和标号分别代表存储单元。变量表示的存储单元中存放数值；标号表示的存储单元中存放指令代码。

## 1 数据定义语句

数据定义语句是最常见的伪指令语句。一般格式如下：

**[变量名] 数据定义符 表达式[,表达式...,表达式] [;注释]** 

数据定义符有：

DB(1) DW(2) DD(4) DQ(8) DT(10) ?<只分配内存单元,不进行初始化> 重复操作符dup

## 2 变量和标号（伪指令）

**变量：**表示存储单元,这种存储单元中存放数值

**标号：**也表示存储单元，这种存储单元中存放机器指令代码

变量和标号均表示存储器操作数，都具有以下**3种属性**：

 1）段值

 2）偏移值

 3）类型

​    \- 变量的类型：有BYTE、WORD、DWORD；

​    \- 标号类型有NEAR(表示段内标号)、FAR(表示段间标号)

在汇编中，变量和标号的这三个属性很重要，汇编语言提供专门的析值操作符和类型操作符，以便对变量和标号的这三个属性进行有关操作处理。例外，还提供了属性操作符来达到按指定属性访问的目的。

-析值操作符：

- SEG（返回变量或标号所在的段值）
- OFFSET（返回变量或标号所在的偏移）
- TYPE（返回变量或标号所在的类型）
- LENGTH（返回dup定义数组元素的个数）
- SIZE（返回dup定义数组占用的字节数）

-属性操作符：

- PTR（明确指明要操作存储器是字节还是字）
- THIS

# 三 常用伪指令语句和源程序组织

## 1 符号定义语句

### 1）等价语句EQU（等同于C语言的#define）

一般格式如下： 

符号名 EQU 表达式

a.用符号来代表常数或数值表达式

| **COUNT EQU 100** | **BUFF_LEN EQU 4\*COUNT** |
| ----------------- | ------------------------- |
|                   |                           |

b.用符号表示一个字符串

**HELLO EQU 'How are you!'**

c.重新定义关键字或指令助记符,即汇编语言关键字或指令助记符起一个别名

**MOVE EQU mov**  **COUNT EQU cx**

### 2）等号语句（等同于C语言的const类型常量）

汇编语言还专门提供等号语句来定义符号常数，即用符号表示一个**常数**。格式如下：

  符号名 = 数值表达式

### 3）定义符号名语句

符号名 LABEL 类型(其中类型可取：BYTE/WORD/DWROD/NEAR/FAR等)

该语句的功能是定义有符号名制定的符号，使该符号的段属性和偏移属性与下一个紧接着的存储单元的段属性和偏移属性相同，使该符号的类型为参数所规定的类型。例如：

 

```
BUFFER LABEL WORD
BUFF DB 100 dup(0)
QUIT LABEL FAR
EXIT: mov ah,4ch
```

## 2 段定义语句

### 1）段开始和段结束语句

汇编语言源程序的段以开始语句开始，以结束语句结束。格式如下：段名 SEGMENT [定义类型] [组合类型] ['类别']  ....段名 ENDS  例如：DSG segment.... DSG ends

**当段名被引用时，表示对应段的段值。**由于指令语句和数据定义语句都要占用存储单元，所以他们一定要安排在某个程序的段内。

### 2）段使用设定语句

  汇编程序根据段开始语句和段结束语句判断出源程序的段划分，为了有效地产生目的代码，汇编程序还要了解各程序段与段寄存器间的对应关系。

段寄存器与程序段的对应关系由段使用设定语句说明。

**ASSUME 段寄存器,段名[,段寄存器,段名,.....]**

  段寄存器名可以是CS、DS、ES和SS。段名就是段开始语句中定义的段名。它表示，从现在开始某寄存器对应指定的段名。

ASSUME伪指令中段名域也可以是一个特别的关键字**NOTHING，**它表示某个段寄存器不再与任何段有对应关系。

  当在使用变量时，需要考虑要不要用段超越前缀，判断要不要再与该变量所在的段是否被绑定到对应的段寄存器，这样汇编程序在汇编时就会自动加上段地址，如果没有，则需要手动加上段超越前缀，否则汇编程序会找不到该变量。

### 3）ORG语句

  汇编程序在对源程序汇编的过程中，使用**地址计数器**来**保存当前正在汇编的指令或者变量的地址偏移**。通常地址计数器的值逐步递增，但程序员可利用ORG语句调整地址计数器的当前值。

**ORG 数值表达式**功能：使地址计数器的值调整成数值表达式的结果值，如数值表达式的值是n，那么ORG伪指令语句使下一个字节的地址成为n。另外，汇编语言用符号“$”表示地址计数器的当前值。

## 3 汇编语言源程序的组织

NAME1   segment  .....NAME1   ends NAME2   segment  .....NAME2   ends NAMEn   segmegnt  .....NAMEn   endsEND    **标号**

  一个完整的程序还应该带有自己的堆栈段，但操作系统(DOS)在装载没有堆栈段的程序时，会指定一个堆栈段。由于堆栈段，因此当程序比较简单时可以不定义自己的堆栈。尽管在链接是会发出一条警告信息。

# 四 顺序程序设计

在具体的顺序程序片段中，有些指令可以前后颠倒，有些却不行。此外，还要注意顺序的优化，做到充分利用前面的处理结果，尽量避免重复操作。

# 五 分支程序设计

| if(a>xxx){  ...}                                          | JBE IF_END IF_BEGIN  ...IF_END                               |
| --------------------------------------------------------- | ------------------------------------------------------------ |
| if(a>xxx){  ...}else{  ...}                               | jBE ELSE_BEGINIF_BEGIN:  ...IF_END  jmp ELSE_ENDELSE_BEGIN  ...ELSE_END |
| switch(){  case 1: ...;  case 2: ...;  ...  case n: ...;} | mov reg,menjxx xxx1jxx xxx2jxx xxx3jmp END...1JMP END...2JMP END...3JMP END |

# 六 循环程序设计

| for(i=xxx;i<Step;i++){ //循环体 ......} | mov men/reg,xxx ;赋初值jmp FOR_CMPFOR_STEP:    ;步长计算部分mov reg,Stepadd reg,xxxmov Step,xxxFOR_CMP:     ;循环条件判断部分mov ecx,dword ptr Stepcmp ecx,StepEndjxx FOR_END...jmp FOR_STEPFOR_END: |
| --------------------------------------- | ------------------------------------------------------------ |
| while(TRUE){ ...}                       | WHILE_BEGIN:JXX WHILE_END ... jmp WHILE_BEGINWHILE_END       |
| do{ ...}while(..);                      | DO_BEGIN:...  ;循环语句块JXX DO_BEGIN                        |