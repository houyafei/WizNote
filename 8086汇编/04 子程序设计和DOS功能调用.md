# **一 子程序设计**

如果某个程序片段将反复出现，就把它设计成**子程序**。

1）能有效地缩短程序长度、节约存储空间

2）减轻程序设计的工作量

3）便于模块化，也便于阅读和修改

## **1 过程调用和返回指令**

**过程调用：**主程序转子程序

**过程返回：**子程序返回主程序

过程调用有**段内调用**和**段间调用**之分，与之对应，过程返回指令也有**段内返回**和**段间返回**之分。

把段内调用和段内返回称为**近调用和近返回**，把段间调用和段间返回称为**远调用和远返回**。

### **1）过程调用指令**

按照转移目标是否在同一段来分，调用指令分为**段内调用**和**段间调用**；

按照获得转移目标地址的方式来分，调用指令分为**直接调用**和**间接调用**。

-段内直接调用：**CALL 过程名(同段)**

-段内间接调用：**CALL OPRD(16位寄存器或存储器操作数)**

**相当于 ==> push IP, jmp OPRD**

-段间直接调用：**CALL 过程名(不同段)**

-段间间接调用：**CALL OPRD(双字存储器操作数，32位)**

**等同于 ==> push CS; push IP ; jmp OPRD**

### **2）过程返回**

-段内返回指令：RET

**等同于 ==>** **pop IP sp=sp+2;**

-段间返回指令：RET

**等同于 ==>** **pop IP; SP=SP+2; pop CS; SP=SP+2;**

**RETF**

不管是段内还是段间都强制汇编成段间返回指令

RET 表达数

段内带立即数返回指令

## **2 过程定义语句**

利用过程定义伪指令语句，可把程序片段声明为具有近类型或远类型的过程，并且能给过程器一个名字。**过程名  PROC [ NEAR | FAR ]**   **...**  **...****过程名  ENDP**

如果不指定**，默认是(NEAR)近类型，只能被本段调用**，要被其他的段调用，需要声明为（FAR）远类型。

## **3 子程序说明信息**

  为了能正确地使用子程序，在给出子程序代码时还需要给出子程序的说明信息。

子程序说明信息一般由如下几部分组成(至少有前三部分内容):

a.子程序入口b.功能描述c.入口和出口参数d.所用的寄存器和存储单元e.使用的算法和重要的性能指标f.其他调用注意事项和说明信息g.调用实例

## **4 寄存器的保护和恢复**

在子程序运行时通常会破坏一些寄存器或存储单元的原有内容，因此，要对有关寄存器或存储单元的内容进行保护与恢复。

寄存器的保护和恢复有两种方法：

1）把需要保护的寄存器的内容，在主程序中压入堆栈中和弹出堆栈。        **// 调用前保护**

2）在子程序一开始压入要改变的寄存器内容，然后在返回前恢复这些寄存器。 **// 子程序中执行前保护**

**注意：**

a. 子程序还破坏标志寄存器的部分标志，可用PUSHF和POPF。但一般不在子程序中保护和恢复标志寄存器。b. 要注意堆栈的先进后出特性c. 是否要保护入口参数寄存器，可以根据实际情况事先约定，d. 在子程序中应**尽量避免把普通存储单元作为临时变量使用**，可以利用堆栈元素作为临时变量使用。

# **二 主程序与子程序间的参数传递**

  主程序与子程序之间这种信息传递称为**参数传递**，我们把由主程序传给子程序的参数称为**子程序入口参数**，把由子程序传给主程序的参数称为子程序的**出口参数**。

**1 利用寄存器传递参数**

把参数放在约定的寄存器中，优点是实现简单和调用方便，但**只适用于传递参数较少**的情况。

**2 利用约定存储单元传递参数**

  在参数较多的情况下，可利用约定的内存变量来传递参数。这种方法的优点是子程序要处理的数据或送出的结果都有独立的存储单元，编写程序时不易出错。但这种方法要占用一定的存储单元，通用性较差。为了传递较多的参数，又要保持良好的通用性，**通常把参数组织成一张参数表，存放在某个存储区，然后把这个存储区的首地址传递给子程序，即可利用寄存器传递首地址，也可以利用堆栈方法传递首地址。**

**3 利用堆栈传递参数(高级语言常用)**

  如果使用堆栈传递入口参数，那么主程序在调用子程序之前，把需要传递的参数依次压入栈中，子程序从堆栈中取入口参数；如果使用堆栈传递出口参数，那么子程序在返回前，把需要返回的参数存入堆栈，主程序在堆栈中取出口参数。

  利用堆栈传递参数可以不占用寄存器，也无需使用额外的存储单元。但由于参数和子程序的返回地址混杂在一起，有时还有考虑保护寄存器，所以较为复杂。**通常利用堆栈传递入口参数，而利用寄存器传递出口参数**。

**4 利用call后续区传递参数（略）**

# **三 DOS功能调用及应用**

**1 什么是DOS功能调用**

MS-DOS内包含了许多设计设备驱动和文件管理等方面的子程序，DOS的各种命令就是通过适当地调用这些子程序实现的。

为了方便程序员使用，把这些子程序编写成相对独立的程序模块而且编上号。这些编了号的可由程序员调用的子程序就称为DOS的**功能调用或称为系统调用**。

一般认为**DOS的各种命令**是操作员与DOS的接口，而**功能调用**则是程序员与DOS的接口。

  DOS功能调用主要包括三方面：**设备驱动(基本I/O)、文件管理和其他**（包括内存管理、置取时间、置取中断向量、终止程序等）。

**2 调用方法**

1）根据需要调用的功能调用准备入口参数

2）把功能调用号送入**AH**寄存器

3）发软中断指令 **INT 21H**

**3 基本I/O功能调用**

| AH   | 功能                               | 入口参数                                      | 出口参数                                                     |
| ---- | ---------------------------------- | --------------------------------------------- | ------------------------------------------------------------ |
| 01   | 键盘键入并回显检测Ctrl+Break/C     |                                               | AL=输入字符                                                  |
| 02   | 显示输出                           | DL=要输出字符                                 |                                                              |
| 03   | 异步通讯输入                       |                                               | AL=输入数据                                                  |
| 04   | 异步通讯输出                       | DL=输出数据                                   |                                                              |
| 05   | 打印机输出                         | DL=输出字符                                   |                                                              |
| 06   | 直接控制台I/O                      | DL=0FFH时表示输入;否则表示输出，DL=输出的字符 | 输入：ZF=1，表示无字符可读；ZF=0，表示读到字符，AL=输入字符；输出时，无。 |
| 07   | 键盘键入(无回显)                   |                                               | AL=输入字符                                                  |
| 08   | 键盘键入(无回显)检测Ctrl+Break/C   |                                               | AL=输入字符                                                  |
| 09   | 显示字符串                         | DS:DX=串地址,'$'结束字符串                    |                                                              |
| 0A   | 键盘输入到缓冲区                   | DS:DX=缓冲区首地址(DS:DX)=缓冲区最大字符数    | (DS:DX+1)=实际输入的字符数                                   |
| 0B   | 检验键盘状态                       |                                               | AL=00 有输入AL=FF 无输入                                     |
| 0C   | 清除输入缓冲区并请求指定的输入功能 | AL=输入功能号(1,6,7,8,A)                      |                                                              |

标号01/07/08、0A:键盘键入和输入到缓冲区

标号03、04异步输入输出

标号02、05、09输出字符、打印机输出和输出字符串

标号06、0B/0C:直接控制台I/O、检验键盘状态和清除输入缓冲区

# **四 磁盘文件管理及应用**

  DOS磁盘文件管理功能调用中，用于表示文件名的ASCII字符串必须以ASCII码值0结尾，这样的字符串称为ASCIIZ串。文件名可以是包含盘符和路径的文件标识。

如么有盘符，那么认为是当前盘，如路径不是从根目录开始，那么就认为从当前目录开始。这些功能调用均利用**CF**表示调用是否成功，如果不成功，那么AX含有错误代码。常见错误代码有：

01 无效的功能号

02 文件未找到

03 路径未找到

04 同时打开文件太多

05 拒绝存取

06 无效的文件号

| AH   | 功能                               | 入口参数                                                     | 出口参数                                                     |
| ---- | ---------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 3C   | 建立文件（创建新的或刷新老的文件） | DS：DX=代表文件名的字符串的首地址 CX=文件属性                | CF=0 成功，AX=文件号 CF=1 失败，AX=错误码                    |
| 3D   | 打开文件                           | DS：DX=代表文件名的字符串的首地址 AL=存取方式                | CF=0 成功，AX=文件号 CF=1 失败，AX=错误码                    |
| 3E   | 关闭文件                           | BX=文件号                                                    | CF=0 表示成功 CF=1 表示失败                                  |
| 3F   | 读文件                             | BX=文件号 CX=读入字节数 DS：DX=准备存放所读数据的缓冲区首地址 | CF=0 成功，AX=实际读字节数 CF=1 失败，AX=错误代码            |
| 40   | 写文件                             | BX=文件号 CX=写盘字节数 DS：DX=存放写数据的缓冲区首地址      | CF=0 成功，AX=实际写入字节数 CF=1 失败，AX=错误代码          |
| 41   | 删除文件                           | DS：DX=代表文件名的字符串首地址                              | CF=0 表示成功 CF=1 表示失败，AX=错误代码                     |
| 42   | 移动文件（读写）指针               | BX=文件号 CX：DX=移动位移量 AL=移动方式                      | CF=0 成功，DX：AX=移动后文件指针值 CF=1 失败，AX=1表示无效的移动方式，AX=6表示无效文件号 |

# **五 子程序的递归和重入**

## **1 递归子程序**

  如果一个子程序直接调用它自身，这种调用称为**直接递归调用**，如果一个子程序间接调用它自身，这种调用称为**间接递归调用**。具有递归调用的子程序就称为**递归子程序**。递归是嵌套的特殊情形。

递归子程序必须采用寄存器或堆栈传递参数。递归的深度受堆栈空间的限制。

## **2 可重入子程序**

  **子程序的重入是指子程序在中断后被重新调用**，子程序的重入不同于子程序的递归，重入是被动行为，而递归是主动行为，重入前的调用和重入调用往往是不相干的，而递归调用前后却是密切相关的。

我们把能够重入的子程序称为**可重入子程序**。在设计可重入子程序时，必须注意如下几点：

（1）不能利用约定存储单元传递参数。（2）不能使用约定的存储单元保存中间值。