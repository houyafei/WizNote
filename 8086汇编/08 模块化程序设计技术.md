  把一个程序分成具有多个明确任务的程序模块，分别编制、调试后再把它们连接在一起，形成一个完整的程序，这样的程序设计称为**模块化程序设计**。

模块化程序设计有如下优点：

（1）单个程序模块易于编写。调试及修改

（2）若干程序员可以并行工作，工作进度可加快

（3）若干反复使用和验证过的程序模块可被利用

（4）程序的易读性好

（5）程序的修改可局部化

模块化程序设计的主要**步骤如下**：

(1)正确地描述整个程序需要完成什么样的工作

(2)把完整的任务划分成多个具有明确功能的程序模块，并明确各模块之间的相互关系

(3)根据各模块的具体功能和地位，选择合适的选择设计语言，编写程序并初步调试

(4)把各模块分别编译或汇编成目标模块，并连接到一起，经过调试形成一个完整的程序

(5)整理文档资料

# 一 段的完整定义

## **1** **完整的****段定义**

完整的段定义提供了彻底控制段的机制，该机制可使个模块的各个段严格按要求组合和衔接。

### 1）一般格式

**段名  SEGMENT  [定位类型]  [组合类型]  ['类别']**  **......**  **语句**  **......****段名  ENDS**** ****定义类型：如何衔接相邻的两个段****组合类型:各同名段如何组织在一起****类别：表示段的分类**

  **段名可以是唯一的，也可以与程序中其他的段名相同。**在同一模块中，如果已用相同的段名定义过段，那么当前这个段被视为前一个同名段的继续，即同一个段。

  对一个模块中的同名段而言，后续同名段的定义伪指令**SEGMENT**中的可选项取值应该与前一个同名段相同，或者不在给定而默认与前一个同名段相同。

### 2）定位类型

定位类型表示出当前段对起始地址的要求，从而指示连接程序如何衔接相邻两段。

| 定位类型       | 含义                                   |
| -------------- | -------------------------------------- |
| **BYTE**       | 使用下一个可用字节地址                 |
| **WORD**       | 使用下一个可用字地址(16位偶地址开始)   |
| **DWORD**      | 使用下一个可用双子地址(32位偶地址开始) |
| **PAPA(默认)** | 使用下一个可用节地址(16个字节)         |
| **PAGE**       | 使用下一个可用页地址(一页等于256字节)  |

**3）组合类型**

 不同模块的同名段的组合，为了更有效更便利地使用存储器提供了方便。**组合类型就是用于通知连接程序，如果把不同模块内段名相同的段组合在一起**。

| 组合类型 | 说明                                                         |
| -------- | ------------------------------------------------------------ |
| PUBLIC   | 组合类型PUBLIC表示当前段与其他模块中组合类型为PUBLIC的同名段组合成一个段。组合的先后顺序取决于启动LINK程序时目标模块名排列的次序。由于组合后受同一段地址控制，所以组合时遵循定位类型进行衔接。 |
| COMMON   |                                                              |
| STACK    | 组合类型STACK表示当前段是堆栈段，组合情况与PUBLIC相同。      |
| MEMORY   | 组合类型MEMORY与组合类型PUBLIC相同，为兼容而设。             |
| AT表达式 |                                                              |
| PRIVATE  | 这类型PRIVATE表示不与其他段组合。宏汇编程序MASM不识别此关键字。 |

**4）类别**

类别用于表示段的分类。LINK程序总是使类别相同的段相邻。实际上只有类别相同的同名段才根据组合类型进行组合。

**类别**是一个由程序员指定的字符串，但必须用单引号括起。如果一个段没有给出类别，那么这个段的类别就为空。

## 2 关于堆栈段的说明

一个完整的程汇编语言源程序一般应该含有一个堆栈段，只有COM型程序例外。

**当把某个段的组合类型制定为STACK时，这个段就被指定为堆栈段。**也就是说，组合类型STACK不仅是某种组合类型，而且能够表示当前段是堆栈段。如果在程序的其他模块中也有组合类型为STACK的同名段，那么连接时将以接续的方式组合到一起，这样会构成一个存储空间更大的堆栈。

## 3 段组的说明和使用

伪指令GROUP用于把源程序模块中若干不同名的段集合成一个**组**，并赋予一个**组名**。

组名  GROUP  段名[,段名......]

# 二 段的简化定义

## 1 存储模型说明伪指令

在程序中使用段简化定义伪指令之前，必须先使用存储模型说明伪指令描述程序采用的存储模型。

 

```
.MODEL    存储模型
```

常见模型有:

| SMALL   | 全部数据限制在单个64K的段内,代码也限制在单个64K段内 |
| ------- | --------------------------------------------------- |
| medium  | 全部数据限制在单个64K的段内,但代码可大于64K         |
| compact | 数据总量可大于64K,但代码限制在单个64K段内           |
| large   | 数据和代码均可超过64K,但一个数组不能大于64K         |
| huge    | 数据和代码均可超过64K,并且一个数组也能大于64K       |

**2 简化的段定义伪指令**

**1）简化的段定义伪指令**

简化的段定义伪指令均以符号点引导。

|                                | 格式                      |
| ------------------------------ | ------------------------- |
| 定义代码段伪指令               | .CODE                     |
| 定义堆栈段的伪指令             | .STACK [栈大小(默认1024)] |
| 定义数据段伪指令               | .DATA.DATA?.CONST         |
| 定义远程（独立）数据段的伪指令 | .FARDATA  [名字]          |

**2）缺省段名**

![img](file:///C:/Users/chen/Documents/My Knowledge/temp/d522bee7-5c29-491f-b8b6-07a67be7edf8/128/index_files/166b4c48-3551-449d-b0e0-2e07e1e5c53b.jpg)

**3 存储模型说明伪指令的隐含动作**

**1）隐含的段组和段设定**

**![img](file:///C:/Users/chen/Documents/My Knowledge/temp/d522bee7-5c29-491f-b8b6-07a67be7edf8/128/index_files/92c882cf-4280-441d-9124-b3ba451148c0.jpg)
**

**2）有关的预定义符**

**![img](file:///C:/Users/chen/Documents/My Knowledge/temp/d522bee7-5c29-491f-b8b6-07a67be7edf8/128/index_files/815eaeb5-0e5b-45ef-82c1-255c6a92ec27.jpg)
**

# 三 模块间的通信（略）

# 四 子程序库（略）

# 五 编写供Turbo C调用的函数（略）